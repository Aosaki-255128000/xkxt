```sql
ALTER TABLE course
ADD CONSTRAINT id_department 
FOREIGN KEY (dptId)
REFERENCES department(id)
ON DELETE CASCADE;
```

记得在数据库先建立外键约束。

### 数据库和后端的分工：

1. **数据库的职责：**
   - **定义数据结构：** 包括创建表、定义字段、设置主键、外键、约束（例如 `NOT NULL`、`UNIQUE` 等）。
   - **保证数据完整性和约束：** 通过外键、触发器、检查约束等机制，确保数据逻辑的正确性。例如，防止插入无效的外键。
   - **处理数据：** 高效地存储、索引和检索数据。
   - **执行SQL语句：** 直接运行 SQL 脚本来初始化数据库、维护表结构、进行批量数据处理等。
2. **后端的职责：**
   - **与数据库交互：** 通过执行 SQL 查询、调用存储过程或 ORM（对象关系映射）工具来操作数据。
   - **业务逻辑：** 将数据库的功能抽象成业务逻辑。例如，限制用户只能查看特定范围的数据、在插入前进行额外的校验。
   - **数据处理：** 将数据库返回的原始数据格式化为符合应用需求的结构，供前端或其他服务使用。
   - **接口开发：** 提供 RESTful API 或其他类型的接口，让前端能够通过 HTTP 请求操作数据。

------

### 数据库和后端的操作界限

#### 数据库中的操作：

- 表结构（schema）设计，例如表的创建、列的添加或删除。
- 外键约束、触发器、存储过程的定义。
- 数据库初始化脚本（建表、插入初始数据）。
- 数据迁移，例如修改现有表结构或修复错误数据。

**这些操作通常通过 SQL 脚本或数据库管理工具（如 Navicat、DBeaver 等）完成，而不是在后端中直接完成。**

#### 后端中的操作：

- 针对业务场景的增删改查，例如插入新的数据、更新记录或查询满足条件的数据。
- 对复杂查询的封装，通过调用 Mapper 或 Repository 层来完成。
- 执行动态查询，例如基于用户输入的搜索条件拼接 SQL。
- 数据校验，例如检查用户输入是否符合要求（如字段非空、格式正确）。

**这些操作通常通过代码完成，并间接地与数据库交互。**

------

### 为什么分离操作是必要的？

1. **职责单一：**
   - 数据库专注于管理和维护数据。
   - 后端专注于业务逻辑和接口实现。
2. **高效协作：**
   - 数据库开发人员可以优化表结构、索引等，而后端开发人员可以专注于业务逻辑。
   - 如果数据表结构需要调整，只需数据库开发人员修改 SQL 脚本，而后端代码一般不需要太大改动（如果字段名称和逻辑未变）。
3. **数据完整性：**
   - 外键、约束等在数据库层保证了数据的完整性，即使没有后端，直接操作数据库时也能避免错误数据的产生。
4. **易维护性：**
   - 数据库脚本和后端代码分离后，便于各自的迭代和更新。例如，数据库可以通过版本控制工具管理表结构变更，后端代码也可以独立更新。

------

### 举例说明分工

#### 1. 数据库操作：

- 创建表和外键：

```sql
CREATE TABLE department (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    address VARCHAR(255),
    phone VARCHAR(20)
);

CREATE TABLE course (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    department_id INT NOT NULL,
    credit INT,
    FOREIGN KEY (department_id) REFERENCES department(id) ON DELETE CASCADE
);
```

**数据库层保证：**

- `department_id` 必须存在于 `department` 表中。
- 删除 `department` 表中的记录时，自动删除对应的课程。

------

#### 2. 后端操作：

后端代码针对数据库进行增删查改，比如插入一门课程：

```java
@Service
public class CourseService {

    @Autowired
    private CourseMapper courseMapper;

    @Autowired
    private DepartmentMapper departmentMapper;

    public void addCourse(Course course) {
        // 在插入前校验 department_id 是否存在
        if (departmentMapper.findById(course.getDepartmentId()) == null) {
            throw new IllegalArgumentException("Invalid department ID");
        }
        courseMapper.insert(course);
    }
}
```

**后端负责：**

- 检查 `department_id` 是否有效。
- 提供服务接口，供前端调用。

------

### 总结

- 数据库和后端分离操作是常见的开发模式，数据库主要负责**结构和数据约束**，后端负责**业务逻辑和接口**。
- 像定义外键、创建表这种操作只能在数据库中完成，后端无法直接操作表结构。
- 后端和数据库的分工使开发更加灵活和高效，同时减少了耦合性。

如果你的项目对表结构有频繁变动需求，可以考虑使用工具（如 Flyway、Liquibase）来管理数据库版本更新，从而实现对数据库的更好维护。



------

### 1. 修改 `CourseMapper`，加入关联查询

为了让 `Course` 关联到 `Department`，我们可以在查询课程的同时，使用 `JOIN` 来把 `Course` 和 `Department` 数据关联在一起。你可以在 `CourseMapper` 中定义一个方法来查询包含院系信息的课程数据。

```java
package com.hsy.springboot.mapper;

import com.hsy.springboot.entity.Course;
import com.hsy.springboot.entity.Department;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface CourseMapper {

    @Select("select * from course")
    List<Course> findAll();

    @Insert("insert into course(name, department_id, credit) VALUES (#{name}, #{departmentId}, #{credit})")
    int insert(Course course);

    @Update("update course set name = #{name}, department_id = #{departmentId}, credit = #{credit} where id = #{id}")
    int update(Course course);

    @Delete("delete from course where id =#{id}")
    Integer deleteById(Integer id);

    @Select("select * from course where department_id = #{departmentId}")
    List<Course> findByDepartmentId(Integer departmentId);

    // 关联查询：获取所有课程及对应的院系信息
    @Select("SELECT c.id, c.name, c.department_id, c.credit, d.id AS department_id, d.name AS department_name " +
            "FROM course c JOIN department d ON c.department_id = d.id")
    @Results({
        @Result(property = "id", column = "id"),
        @Result(property = "name", column = "name"),
        @Result(property = "departmentId", column = "department_id"),
        @Result(property = "credit", column = "credit"),
        @Result(property = "department.name", column = "department_name") // 这里表示department关联的名称
    })
    List<Course> findAllCoursesWithDepartment();
}
```

### 2. 修改 `Course` 实体类，嵌套 `Department` 实体

为了映射查询结果到 `Course` 对象，我们可以在 `Course` 实体类中添加一个 `Department` 对象，这样查询到的院系信息可以直接放到 `Course` 实体中。

```java
package com.hsy.springboot.entity;

import lombok.Data;

@Data
public class Course {
    private Integer id;
    private String name;
    private Integer departmentId; // 外键，关联到Department的id
    private Integer credit;

    // 新增一个 Department 属性来保存院系信息
    private Department department;
}
```

### 3. 修改 `CourseService`，调用新的查询方法

在 `CourseService` 中，调用 `CourseMapper` 的新方法来获取关联的课程和院系信息。

```java
package com.hsy.springboot.service;

import com.hsy.springboot.entity.Course;
import com.hsy.springboot.mapper.CourseMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CourseService {

    @Autowired
    private CourseMapper courseMapper;

    public int save(Course course) {
        if(course.getId() == null) {
            return courseMapper.insert(course);
        } else {
            return courseMapper.update(course);
        }
    }

    public List<Course> list() { return courseMapper.findAll(); }

    // 获取包含院系信息的课程列表
    public List<Course> findAllCoursesWithDepartment() {
        return courseMapper.findAllCoursesWithDepartment();
    }

    public List<Course> findByDepartmentId(Integer departmentId) {
        return courseMapper.findByDepartmentId(departmentId);
    }
}
```

### 4. 修改 `CourseController`，添加接口返回课程与院系信息

在 `CourseController` 中，添加一个新的接口，用于查询包含院系信息的所有课程。

```java
package com.hsy.springboot.controller;

import com.hsy.springboot.entity.Course;
import com.hsy.springboot.service.CourseService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/course")
public class CourseController {

    @Autowired
    private CourseService courseService;

    @PostMapping
    public Integer save(@RequestBody Course course) {
        return courseService.save(course);
    }

    @GetMapping
    public List<Course> findAll() {
        return courseService.list();
    }

    @GetMapping("/withDepartment")
    public List<Course> findAllCoursesWithDepartment() {
        return courseService.findAllCoursesWithDepartment();
    }

    @GetMapping("/byDepartment/{departmentId}")
    public List<Course> findByDepartmentId(@PathVariable Integer departmentId) {
        return courseService.findByDepartmentId(departmentId);
    }

    @DeleteMapping("/{id}")
    public Integer delete(@PathVariable Integer id) {
        return courseService.delete(id);
    }
}
```

### 5. SQL 表设计（依然不变）

你可以保持原有的表设计，只需要确保 `course` 表的 `department_id` 字段有外键约束指向 `department` 表的 `id` 字段。

```sql
CREATE TABLE department (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    address VARCHAR(255),
    phone VARCHAR(255)
);

CREATE TABLE course (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    department_id INT,
    credit INT,
    FOREIGN KEY (department_id) REFERENCES department(id)
);
```

### 总结

1. 在 `CourseMapper` 中，使用 `JOIN` 语句将 `Course` 和 `Department` 进行关联查询，并在结果映射时使用 `@Results` 注解将 `Department` 信息映射到 `Course` 对象中。
2. 在 `Course` 实体类中，新增 `Department` 类型的属性，用于保存院系信息。
3. 在 `CourseService` 中，新增方法来获取包含院系信息的课程。
4. 在 `CourseController` 中，暴露一个新的接口来返回包含院系信息的所有课程。

这样，你就能够通过 `Course` 表的 `departmentId` 关联查询到对应的 `Department` 信息。